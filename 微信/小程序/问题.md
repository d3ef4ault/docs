# 问题

## 导入路径问题

- 页面导入js模块使用 **相对路径**
- 页面使用组件路径使用 **绝对路径**

## 定时器问题

**所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用`setTimeout`或者`setInterval`的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理**

## setData

由于小程序的渲染层和逻辑层分别在两个线程中运行，所以**`setData`传递数据实际是一个异步的过程**，所以setData的第二个参数是一个callback回调，在这次setData对界面渲染完毕后触发。
setData其一般调用格式是 `setData(data, callback)`，其中data是由多个key: value构成的Object对象

```js
// page.js
Page({
  onLoad: function(){
    this.setData({
      text: 'change data'
    }, function(){
      // 在这次setData对界面渲染完毕后触发
    })
  }
})
```

**注意：**

- 直接修改 Page 实例的 `this.data` 而不调用 `this.setData` 是无法改变页面的状态的，还会造成数据不一致。
- 由于setData是需要两个线程的一些通信消耗，为了提高性能，每次设置的数据不应超过**1024kB**。
- 不要把data中的任意一项的value设为undefined，否则可能会有引起一些不可预料的bug。

## 页面跳转和路由

假如当前页面是在 `pageB`，当前页面栈为`[ pageA, pageB]`（其中`pageA`为 Tab 页），则：

- `wx.navigateTo({ url: 'pageC' })` 往当前页面栈多推入一个页面 `pageC`
  - （当前页面栈为`[ pageA, pageB, pageC]`）
  - 每使用一次 `wx.navigateTo` 页面层级就会增加一层（*一个页面层级称为页面栈*），后跳转的页面栈在上面
- `wx.navigateBack()` 退出当前页面栈的最顶上页面 `pageC`
  - （当前页面栈为`[ pageA, pageB]`）
- `wx.redirectTo({ url: 'pageD' })` `pageD` 替换当前页面
  - （当前页面栈为`[ pageA, pageD]`）
  - 当页面栈到达10层没法再新增的时候，往往就是使用`redirectTo`这个API进行页面跳转
- `wx.switchTab({ url: 'pageE' })` 除了已经声明为`Tabbar`页的 `pageA` 页面外其他页面（`pageD`）会被销毁，然后会切到`pageE`所在的tab页面
  - （当前页面栈为`[ pageE]`）
  - 此时点击Tab1切回到`pageA`时，`pageA`不会再触发`onLoad`，因为`pageA`没有被销毁
- `wx.reLaunch({ url: 'pageF' })` 重启小程序，并且打开 `pageF`
  - （当前页面栈为`[ pageF ]`）

**`wx.navigateTo` 和 `wx.redirectTo` 只能打开非TabBar页面，`wx.switchTab` 只能打开Tabbar页面**

**小程序宿主环境限制了这个页面栈的最大层级为`10`层 ，也就是当页面栈到达`10`层之后就没有办法再推入新的页面了，当页面栈到达`10`层没法再新增的时候，往往就是使用`redirectTo`这个API进行页面跳转**

|路由方式|触发时机|路由前页面生命周期|路由后页面生命周期|
|---|---|---|---|
|初始化|小程序打开的第一个页面| |onLoad, onShow|
|打开新页面|调用 API wx.navigateTo|onHide|onLoad, onShow|
|页面重定向|调用 API wx.redirectTo|onUnload|onLoad, onShow|
|页面返回|调用 API wx.navigateBack|onUnload|onShow|
|Tab切换|调用 API wx.switchTab|请参考表3-6|请参考表3-6|
|重启动|调用API wx.reLaunch|onUnload|onLoad, onShow|

## `target` 和 `currentTarget`

- `currentTarget` 为当前事件所绑定的组件
- `target` 则是触发该事件的源头组件