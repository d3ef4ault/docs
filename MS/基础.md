# 基础部分

## Event Loop

- 参考
[MDN 并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
[什么是 Event Loop？](http://www.ruanyifeng.com/blog/2013/10/event_loop.html)
[从一道面试题来理解JS事件循环](https://xieyufei.com/2019/12/30/Quiz-Eventloop.html)
[js事件循环机制(Event Loop)](https://www.cnblogs.com/yalong/p/10369477.html)
[浅析 JS 中的 EventLoop 事件循环（新手向）](https://segmentfault.com/a/1190000019313028)

javascript 就是一门`单线程的``非阻塞的``脚本语言`。
单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。
非阻塞靠的就是 event loop（事件循环）。

`event loop` 它最主要是分三部分：**主线程**、**宏队列（macrotask）**、**微队列（microtask）**。
在 javascript 中怎么区分它们呢？

- 主线程
  - 就是访问到的 script 标签里面包含的内容
  - 或者是直接访问某一个js文件的时候，里面的可以在当前作用域直接执行的所有内容（执行的方法，new出来的对象等）
- 宏队列（macrotask）
  - setTimeout
  - setInterval
  - setImmediate
  - I/O
  - UI rendering
- 微队列（microtask）
  - promise.then
  - process.nextTick
  - Object.observe(已废弃)
  - MutationObserver(html5新特性)

- **执行顺序：**
1、先执行主线程
2、遇到宏任务，放到宏任务队列
3、遇到微任务，放到微任务队列
4、主线程执行完毕，接下来检查任务队列中是否有宏（微）任务，如果有就放到主线程执行
5、先执行微任务队列里面的微任务（如果微任务里面还会有宏任务，放到宏任务队列）
6、再执行宏任务队列里面的宏任务（如果宏任务里面还会有微任务，放到微任务队列）
然后再依次执行`4 ~ 5`的过程

- **代码分析：**

```js
console.log(1)
this.$nextTick(() => {
  console.log(8)
  setTimeout(() => {
    console.log(9)
  })
})
setTimeout(() => {
  console.log(2)
  new Promise(() => {
    console.log(11)
  })
})
// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback
// requestIdleCallback 此处只用来做实验室用
requestIdleCallback(() => {
  console.log(7)
})
// 特殊说明： new Promise（）属于主线程任务
let promise = new Promise((resolve,reject) => {
  setTimeout(() => {
    console.log(10)
  })
  resolve()
  // 这个console也属于主线程任务
  console.log(4)
})
fn()
console.log(3)
promise.then(() => {
  console.log(12)
})
function fn(){
  console.log(6)
}
```

执行结果：1、4、6、3、8、12、2、11、10、9、7。

- **代码执行步骤分析：**

1、js从上到下执行，先打印 1；
2、`this.$nextTick` 属于微队列（microtask），并且当前主线程的代码还没有执行完毕，所以它被暂时扔到了微队列里；
3、setTimeout 是属于宏队列（macrotask），跟 `this.$nextTick` 处理逻辑类似，当前主线程的代码还没有执行完毕，所以它被暂时扔到了宏队列里；
4、requestIdleCallback 这时也不会立即执行，这里参见 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback);
5、promise 在实例化的时候，这里的 setTimeout 继续被丢到了宏队列（macrotask）中，并立即执行了 resolve，和接下来的 console 打印了 4；
6、fn 函数直接调用，直接打印 6；
7、console 直接打印 3；
8、promise.then 因为它属于微队列，所以被放到微队列里；
9、到这里主线程里面就没有任何可以执行到东西了，下面开始走微队列（microtask）；
10、第一个被放入微队列的是第2步的 `this.$nextTick`，执行后 console 打印了 8，`this.$nextTick` 里还有 setTimeout 是属于宏队列（macrotask），所以它被暂时扔到了宏队列里；
11、第二个被放入微队列的是第8步的 promise.then，执行后 console 打印了 12；
12、到这里微队列就走完了，下面开始走宏队列（macrotask）；
13、第一个被放入宏队列的是第3步的 setTimeout，执行后 console 打印了 2；此时 new Promise 会立即执行 console 打印了 11；
14、第二个被放入宏队列的是第5步的 promise 里面的 setTimeout，执行后 console 打印了 10；
15、第三个被放入宏队列的是第10步的 `this.$nextTick` 里面的 setTimeout，执行后 console 打印了 9；
16、到这里主线程、宏队列（macrotask）、微队列（microtask）就全都跑完了，在全部跑完的时候，requestIdleCallback 才会执行，打印 7；
17、
