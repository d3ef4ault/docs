# 三次握手和四次挥手

参考
[“三次握手，四次挥手”你真的懂吗？](https://zhuanlan.zhihu.com/p/53374516)
[面试官，不要再问我三次握手和四次挥手](https://yuanrengu.com/2020/77eef79f.html)
[TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633)
[面试官问了一下三次握手，我甩出这张脑图，他服了！](https://mp.weixin.qq.com/s?__biz=MzI1NDU3NzM5Mg==&mid=2247484505&idx=1&sn=bac43aa6e87163e8d6719c8907c2d574&chksm=e9c25bc6deb5d2d0e7bf2031982fb13a313bdf3d0eb0fb9e72f9d079c657b21701d2fa42e2b4&scene=126&sessionid=0&clicktime=1589608611#rd)
[通俗大白话来理解TCP协议的三次握手和四次分手](https://github.com/jawil/blog/issues/14)
[理解TCP为什么需要进行三次握手(白话)](https://www.cnblogs.com/yuilin/archive/2012/11/05/2755298.html)

[TOC]

## 什么是“3次握手，4次挥手”

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此之间建立一条连接，所谓的“连接”，其实是**客户端和服务器的内存里保存的一份关于对方的信息（如：IP地址、端口号等）。**

TCP 可以看成是一种字节流，它会处理IP层或者以下的层的丢包、重复以及错误的问题。在连接的建立过程中，双方需要交换一些连接的参数，这些参数可以放在 TCP 头部。

TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，采用四次挥手关闭一个连接。其核心思想：**既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！**

## TCP 服务模型

在了解了建立连接、关闭连接的“三次握手，四次挥手”后，我们再来看下TCP相关的东西。

一个TCP连接由一个四元组构成，分别是两个IP地址和两个端口号。

一个TCP连接通常分为三个阶段：启动、数据传输、退出。

当TCP接受到另一端的数据是，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会，ACK是累计的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样一个好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。

一个完整的TCP连接是双向的对称的，数据可以在两个方向上平等的流动。给上层应用程序提供一个`双工服务`。一旦建立一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的ACK。

序列号的作用是使得一个TCP的接收端可丢弃重复度报文段，纪录以杂乱顺序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供消除或者保证顺序正确的功能，另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到确实的小序列号的报文段被填满。

当一个连接被建立或终止时，交换的报文段只包含TCP头部，而没有数据。

## “3次握手，4次挥手”怎么完成的

其实三次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。

三次握手发送了三个报文段，四次挥手是发送了四个报文段。SYN和FIN段都是会利用重传进行可靠传输的。

### 三次握手

> seq是序列号，这是为了连接以后传送数据用的,是数据包本身的序列号；
> ack是期望对方继续发送的那个数据包的序列号。

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。
  - 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。
  - 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y，如果有丢失的情况，则会重传。
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
  - 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。

### 四次挥手

- 第一次挥手：客户端发送一个FIN段，并包含一个希望接受者看到的自己当前的序列号K，同时还包含一个ACK表示确认对方最近一次发过来的数据。
  - 此时客户端处于 FIN_WAIT1 状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1(K+1) 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
  - 服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。
  - 客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
  - 这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。
  - 此时服务端处于 LAST_ACK 的状态。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。
  - 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
  - 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。

## 为什么要“3次握手，4次挥手”

### 三次握手

客户端和服务端通信前要进行连接，“三次握手”的作用就是**双方都能明确自己和对方的收、发能力正常**。

- 第一次握手：客户端发送网络包，服务端收到了，这样服务端就得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。
- 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一次握手后服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而第三次握手时，服务端接收到了客户端对第二次握手做的回应。从服务端的角度，我在第二次握手时的响应发送出去了，客、客户端接收到了，所以，我的发送能力是正常的，客户端的接收能力也是正常的。

经历过上面的 三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的，之后就可以进行通信了。

### 四次挥手

TCP连接是双向传输的对等模式，就是说双方都可以同时向对方发送或接收数据。

- 当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。
- 这时对方会回一个ACK，此时一个方向的链接关闭。
- 但是另一个方向仍然可以继续传输数据，等到发送完了所有数据后，会发送一个FIN段来关闭此方向上的连接。
- 接收方发送ACK确认关闭连接。

注意：接收到FIN报文的一方只能回复一个ACK，它无法马上返回对方一个FIN报文段，因为结束数据传输的指令是上层应用层给出的。

## 为什么建立连接是三次握手，而关闭连接却是四次挥手呢

这是因为服务端在LISTEN状态下，收到客户端发送的建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，当服务端收到客户端的FIN报文时，仅仅标识客户端不在发送数据了，但是客户端还是能接收数据，服务端是否现在关闭发送数据通道，需要上层应用来决定。因此，服务端ACK和FIN一般都会分开发送。

## 三次握手过程中如果包丢失没有被对方接收到怎么处理

假设 A <---> B 传输

- 第一个包，即A发给B的SYN 中途被丢，没有到达B
  - A会周期性超时重传，直到收到B的确认
- 第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A
  - B会周期性超时重传，直到收到A的确认
- 第三个包，即A发给B的ACK 中途被丢，没有到达B
  - A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：
    - 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。
    - 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的 Data。
    - 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。

## 三次握手过程中可以携带数据吗

其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**。

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。
而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

## 2MSL等待状态

TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

## 四次挥手释放连接时，等待2MSL的意义?

> MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

**两个理由：**

- 保证客户端发送的最后一个ACK报文段能够到达服务端。
这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
- 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态

理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

## “三次握手，四次挥手”进阶

### 连接队列

在外部请求到达时，被服务程序最终感知到前，连接可能处于 SYN_RCVD 状态或是 ESTABLISHED 状态，但还未被应用程序接受。

对应地，服务器端也会维护两种队列，处于 SYN_RCVD 状态的半连接队列，而处于 ESTABLISHED 状态但仍未被应用程序 accept 的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。

#### 半连接队列满了

在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

#### 全连接队列满

当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。

当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。

服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端。

关于SYN-ACK 重传次数的问题：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

### ISN

三次握手的一个重要功能是客户端和服务端交换ISN（Initial Sequence Number），以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果ISN是固定的，攻击者很容易猜出后续的确认号。

`ISN = M + F(localhost, localport, remotehost,remoteport)`

- M 是一个计时器，每隔4毫秒加1；
- F 是一个Hash算法，根据源IP、目的IP、源端口、目的端口，生成一个随机数。要保证Hash算法不能被外部轻易推算出来。

### 序列号回绕

因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。

### syn flood攻击

最基本的DOS攻击就是利用河里的服务请求来占用过多的服务资源，从而使合法的用户无法得到服务的响应。syn flood 数据Dos攻击的一种。

如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block），从而消耗大量的服务器资源，同时也使得正常的连接请求无法被响应。
当开发了一个TCP端口后，该端口就处于Listening状态，不停的监视发到该端口的SYN报文，一旦接收到Client发来的 SYN报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN、ACK命令，立即转为SYN-RECEIVED即半开连接状态，系统会为此耗尽资源。

**常见的防攻击方法有：**

#### 无效连接的监视释放

监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。
这种方法对于所有的连接一视同仁，而且由于SYNFlood造成的半开连接数量很大，正常连接请求也被淹没在其中，被这种方式误释放掉，因此，这种方法数据入门级别的SYN Flood方法。

#### 延缓TCB分配方法

消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。
而SYN Flood由于很难建立起正常的连接，因此，当正常连接建立起来后再分配TCB则可以有效的减轻服务器资源的消耗。
常见的方法是使用 Syn Cache和Syn Cookie技术。

#### Syn Cache 技术

系统在收到一个SYN报文时，在一个专用的HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这种开销远小于TCB的开销，当然还需要保存序列号。

#### Syn Cookie技术

Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。

#### 使用SYN Proxy防火墙

一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c', 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。

## 小结

当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.

从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。

一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。
